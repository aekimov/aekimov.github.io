<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h4>This tutorial will demonstrate the usage of Combine for handling networking tasks.</h4> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4-VIloWfBF6RKjiWU9mwsg.jpeg"><figcaption>Picture from <a href="https://www.freepik.com/author/stories" rel="external nofollow noopener" target="_blank">Storyset</a> onÂ <a href="https://www.freepik.com/free-vector/setup-wizard-concept-illustration_7140756.htm#query=sequence%20request&amp;position=1&amp;from_view=search&amp;track=ais" rel="external nofollow noopener" target="_blank">Freepik</a></figcaption></figure> <h4><strong>Introduction</strong></h4> <p>Most likely, all of us have encountered situations where weâ€™ve had to write code likeÂ this:</p> <pre>photoManager.getAccess { accessResult in<br>    switch accessResult {<br>    case .success:<br>        photoManager.selectPhoto { selectionResult in<br>            switch selectionResult {<br>            case .success:<br>                photoManager.uploadPhoto { uploadResult in<br>                    ...<br>                }<br>            case .failure: <br>                ...<br>            }<br>        }<br><br>    case failure:<br>        photoManager.showAlert {<br>            photoManager.retry {<br>                ...<br>            }<br>        }<br>    }<br>}</pre> <p>This is commonly referred to as the <a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" rel="external nofollow noopener" target="_blank">Pyramid of Doom</a>â€Šâ€”â€Ša code structure that resembles an arrowhead and is considered an anti-pattern resulting from multiple nested closures or structures such as nested conditions or switch statements.</p> <p>In this material, we will explore how to eliminate nested closures using Combine and thus simplify the code while enhancing its readability and maintainability. Letâ€™s explore how it can be valuable for handling asynchronous tasks, such as networking.</p> <h4>API</h4> <p>As an example, I will be using the <a href="https://api.chucknorris.io/" rel="external nofollow noopener" target="_blank">chucknorris.io</a><strong> </strong>API, which provides hand-curated Chuck Norris facts. After all, who doesnâ€™t enjoy Chuck Norris facts?Â ðŸ˜Ž</p> <p>API method to retrieve a list of available categories:</p> <pre>https://api.chucknorris.io/jokes/categories</pre> <p>API method to retrieve a random joke from a given category:</p> <pre>https://api.chucknorris.io/jokes/random?category={category}</pre> <p>To get the jokes, we need to load the possible categories (an array of strings) and then make another request to get the joke for a particular category. We have a chain of requests that go one after theÂ other.</p> <h4>Start Project</h4> <p>Firstly, letâ€™s take a quick look at the initial project I created. You can find it on <a href="https://github.com/aekimov/CombineMultipleRequests" rel="external nofollow noopener" target="_blank">GitHub</a> with a detailed history of changes made to theÂ code.</p> <p>It includes two modelsâ€Šâ€”â€ŠCategory and Jokeâ€Šâ€”â€Šboth of which have only one field of typeÂ String.</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0cc599fad6592b60f03ed75abe83ee38/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/0cc599fad6592b60f03ed75abe83ee38/href</a></iframe> <p>There is also a UITableView with UIRefreshControl which has a target action onRefresh to trigger an update. The implementation of table viewâ€™s delegate methods moved to the extension.</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4c7fa6d2621fd8f8f56ae92507ef3ff7/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/4c7fa6d2621fd8f8f56ae92507ef3ff7/href</a></iframe> <p>Additional helpers:</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a10617f67537d4c4ea39c92f92fab0e7/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/a10617f67537d4c4ea39c92f92fab0e7/href</a></iframe> <p>We need to implement updateJokes to fetch data from the remote, map it and assign it to the jokes property.</p> <h4>Adding Combine Publishers</h4> <p>First, we need to load categories. I encapsulated the logic into a function loadCategories.</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/86a6672aea6282d0aa910317cd396a9f/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/86a6672aea6282d0aa910317cd396a9f/href</a></iframe> <p>Letâ€™s take a look at whatâ€™s going on in thisÂ code.</p> <h4>DataTaskPublisher</h4> <p>Combine ships with built-in support for creating publishers based on URL/ URLRequest similar to the dataTask API that weâ€™ve all used. We can use dataTaskPublisher method of URLSession to get a publisher that wraps a data task for a givenÂ URL.</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/edbbfc014dc4b2cfec755d4755de1dcb/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/edbbfc014dc4b2cfec755d4755de1dcb/href</a></iframe> <p>Below we seeOutput and Failure types of DataTaskPublisher</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5b94d9fb33499656b6c20835e5f6b5a4/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/5b94d9fb33499656b6c20835e5f6b5a4/href</a></iframe> <p>The Output type is a tuple that consists of both the data and the response. The Failure type is set to URLErrorÂ .</p> <h4>TryMap</h4> <p>Since DataTaskPublisher could result with an error we need to handleÂ it.</p> <p>tryMap takes a closure as its parameter and returns a new element. If the closure throws an error, the publisher fails with the thrown error. Here we can also check the response and the statusÂ code.</p> <h4>Decode</h4> <p>Use decode with a JSONDecoder to decode data received from a DataTaskPublisher using the Decodable protocol.</p> <h4>Map</h4> <p>Combineâ€™s map operator performs a function similar to that of <em>map</em> in the Swift standard library: it uses a closure to transform each element it receives from the upstream publisher. You use it to transform from one kind of element toÂ another.</p> <p>I think that the functional representation makes it easier to reason about theÂ code.</p> <p>Next, we will load jokes that match the specified categories, starting with just one joke for now. The code implementation is almost identical, we will refactor itÂ later..</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2d4ec499f25e06c7f74cd2f830a70ab9/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/2d4ec499f25e06c7f74cd2f830a70ab9/href</a></iframe> <p>Our next step is to link these methods together. Letâ€™s create a new function where the magic happens and all these methods areÂ chained.</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/391c1151f4bf7fd63d51c5fda35570e4/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/391c1151f4bf7fd63d51c5fda35570e4/href</a></iframe> <h4>FlatMap</h4> <p>The flatMap(maxPublishers:_:) operator transforms a <em>publisher</em> into completely <em>new publisher</em> that produces elements of the same type. It is used when you want to reach into inner publisher to get its elements.</p> <p>First we load the categories, when we finish loading the categories, flatMap will pass the result to loadJoke and execute the secondÂ request.</p> <p>The final step is to subscribe to the publisher. We can do it in the updateJokes method that we leftÂ empty.</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/16b697e98177ece40c8f274088c7478b/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/16b697e98177ece40c8f274088c7478b/href</a></iframe> <p>We use our loadData method to get the publisher. Use the receive(on:options:) operator to receive results and completion on a specific scheduler, such as performing UI work on the main run loop. This operator changes the execution context of downstream messages.</p> <p>We use sink(receiveCompletion:receiveValue:)to observe values received by the publisher and process them using a closure you specify. This method creates the subscriber.</p> <p>To hold on to the subscription we need to store it in a set of AnyCancellable.</p> <p>Run the app to see the result. We have chained two requests and retrieved oneÂ quote.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/270/1*x-RUGkSAlG-A95O45DOJgg.gif"></figure> <p>Now we can refactor the loading functionality to the final implementation and gather it in the extension:</p> <iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bed2f64fcc33d3d9444f2e3847dbe1b0/href" rel="external nofollow noopener" target="_blank">https://medium.com/media/bed2f64fcc33d3d9444f2e3847dbe1b0/href</a></iframe> <p>Iâ€™ve made the load function generic so that we can refactor loadCategories and loadJoke. Additionally, I have included a loadJokes method that enables us to download a random number of jokes, as opposed to just one as we previously had.</p> <p>We could do it with the help of MergeMany<strong> </strong>publisher which takes an array of upstream publishers and merge them. In order to get an array of jokes we need to apply count operator which emits arrays of at most count elements from an upstream publisher. If the upstream publisher finishes before collecting the specified number of elements, the publisher sends an array of only the items it received. This may be fewer than countelements.</p> <p>Note that MergeMany<strong> </strong>finishes responses of requests in a random order. Use Zip to preserve theÂ order.</p> <p>Final result:</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/270/1*nA_GCRAyTnZwDVWN8mwuZg.gif"><figcaption>Final Result</figcaption></figure> <h4>Conclusion</h4> <p>This is a simple way to execute one or many requests in a sequence when there is a dependency between them using Combine. With Combine, we get all the abstractions like AnyPublisher for free, making the process much simpler. Thereâ€™s no need to handle mutable state, semaphores, or dispatch groups doing it the old way with completion closures, and it is easy to inspect, read, and develop theÂ code.</p> <p>You can find the final project onÂ <a href="https://github.com/aekimov/CombineMultipleRequests" rel="external nofollow noopener" target="_blank">GitHub</a>.</p> <p>Thank you for taking the time to read this article. I hope you found it useful! If you have any questions or comments, please donâ€™t hesitate to leave them below. Iâ€™m always interested in hearing your thoughts.</p> <p>In the next article, I will demonstrate how to use UITableViewDiffableDataSource to refactor UITableView.</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8e19e5c4fa52" width="1" height="1" alt="">&lt;hr&gt;&lt;p&gt;<a href="https://itnext.io/handling-multiple-requests-using-combine-in-swift-8e19e5c4fa52" rel="external nofollow noopener" target="_blank">Handling Multiple Requests Using Combine in Swift</a> was originally published in <a href="https://itnext.io" rel="external nofollow noopener" target="_blank">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</p> </body></html>